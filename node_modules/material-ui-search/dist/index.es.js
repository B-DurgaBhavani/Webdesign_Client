import React, { Component, PureComponent } from 'react';
import PropTypes from 'prop-types';
import IconButton from '@material-ui/core/IconButton';
import Input from '@material-ui/core/Input';
import Paper from '@material-ui/core/Paper';
import ClearIcon from '@material-ui/icons/Clear';
import SearchIcon from '@material-ui/icons/Search';
import { grey } from '@material-ui/core/colors';
import withStyles from '@material-ui/core/styles/withStyles';
import classNames from 'classnames';
import { connect } from 'react-redux';
import { withStyles as withStyles$1 } from '@material-ui/core/styles';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var styles = {
    root: {
        height: 48,
        display: 'flex',
        justifyContent: 'space-between'
    },
    iconButton: {
        opacity: 0.54,
        transform: 'scale(1, 1)',
        transition: 'transform 200ms cubic-bezier(0.4, 0.0, 0.2, 1)'
    },
    iconButtonHidden: {
        transform: 'scale(0, 0)',
        '& > $icon': {
            opacity: 0
        }
    },
    iconButtonDisabled: {
        opacity: 0.38
    },
    searchIconButton: {
        marginRight: -48
    },
    icon: {
        opacity: 0.54,
        transition: 'opacity 200ms cubic-bezier(0.4, 0.0, 0.2, 1)'
    },
    input: {
        width: '100%'
    },
    searchContainer: {
        margin: 'auto 16px',
        width: 'calc(100% - 48px - 32px)' // 48px button + 32px margin
    }

    /**
     * Material design search bar
     * @see [Search patterns](https://material.io/guidelines/patterns/search.html)
     */
};
var SearchBar = function (_Component) {
    inherits(SearchBar, _Component);

    function SearchBar(props) {
        classCallCheck(this, SearchBar);

        var _this = possibleConstructorReturn(this, (SearchBar.__proto__ || Object.getPrototypeOf(SearchBar)).call(this, props));

        _this.handleFocus = function (e) {
            _this.setState({ focus: true });
            if (_this.props.onFocus) {
                _this.props.onFocus(e);
            }
        };

        _this.handleBlur = function (e) {
            _this.setState({ focus: false });
            if (_this.state.value.trim().length === 0) {
                _this.setState({ value: '' });
            }
            if (_this.props.onBlur) {
                _this.props.onBlur(e);
            }
        };

        _this.handleInput = function (e) {
            _this.setState({ value: e.target.value });
            if (_this.props.onChange) {
                _this.props.onChange(e.target.value);
            }
        };

        _this.handleCancel = function () {
            _this.setState({ active: false, value: '' });
            if (_this.props.onCancelSearch) {
                _this.props.onCancelSearch();
            }
        };

        _this.handleKeyUp = function (e) {
            if (e.charCode === 13 || e.key === 'Enter') {
                _this.handleRequestSearch();
            } else if (_this.props.cancelOnEscape && (e.charCode === 27 || e.key === 'Escape')) {
                _this.handleCancel();
            }
            if (_this.props.onKeyUp) {
                _this.props.onKeyUp(e);
            }
        };

        _this.handleRequestSearch = function () {
            if (_this.props.onRequestSearch) {
                _this.props.onRequestSearch(_this.state.value);
            }
        };

        _this.state = {
            focus: false,
            value: _this.props.value,
            active: false
        };
        return _this;
    }

    createClass(SearchBar, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (this.props.value !== nextProps.value) {
                this.setState(_extends({}, this.state, { value: nextProps.value }));
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var value = this.state.value;
            var _props = this.props,
                cancelOnEscape = _props.cancelOnEscape,
                className = _props.className,
                classes = _props.classes,
                closeIcon = _props.closeIcon,
                disabled = _props.disabled,
                onCancelSearch = _props.onCancelSearch,
                onRequestSearch = _props.onRequestSearch,
                searchIcon = _props.searchIcon,
                style = _props.style,
                inputProps = objectWithoutProperties(_props, ['cancelOnEscape', 'className', 'classes', 'closeIcon', 'disabled', 'onCancelSearch', 'onRequestSearch', 'searchIcon', 'style']);


            return React.createElement(
                Paper,
                {
                    className: classNames(classes.root, className),
                    style: style
                },
                React.createElement(
                    'div',
                    { className: classes.searchContainer },
                    React.createElement(Input, _extends({}, inputProps, {
                        onBlur: this.handleBlur,
                        value: value,
                        onChange: this.handleInput,
                        onKeyUp: this.handleKeyUp,
                        onFocus: this.handleFocus,
                        fullWidth: true,
                        className: classes.input,
                        disableUnderline: true,
                        disabled: disabled
                    }))
                ),
                React.createElement(
                    IconButton,
                    {
                        onClick: this.handleRequestSearch,
                        classes: {
                            root: classNames(classes.iconButton, classes.searchIconButton, defineProperty({}, classes.iconButtonHidden, value !== '')),
                            disabled: classes.iconButtonDisabled
                        },
                        disabled: disabled
                    },
                    React.cloneElement(searchIcon, {
                        classes: { root: classes.icon }
                    })
                ),
                React.createElement(
                    IconButton,
                    {
                        onClick: this.handleCancel,
                        classes: {
                            root: classNames(classes.iconButton, defineProperty({}, classes.iconButtonHidden, value === '')),
                            disabled: classes.iconButtonDisabled
                        },
                        disabled: disabled
                    },
                    React.cloneElement(closeIcon, {
                        classes: { root: classes.icon }
                    })
                )
            );
        }
    }]);
    return SearchBar;
}(Component);

SearchBar.defaultProps = {
    className: '',
    closeIcon: React.createElement(ClearIcon, { style: { color: grey[500] } }),
    disabled: false,
    placeholder: 'Search',
    searchIcon: React.createElement(SearchIcon, { style: { color: grey[500] } }),
    style: null,
    value: ''
};

SearchBar.propTypes = {
    /** Whether to clear search on escape */
    cancelOnEscape: PropTypes.bool,
    /** Override or extend the styles applied to the component. */
    classes: PropTypes.object.isRequired,
    /** Custom top-level class */
    className: PropTypes.string,
    /** Override the close icon. */
    closeIcon: PropTypes.node,
    /** Disables text field. */
    disabled: PropTypes.bool,
    /** Fired when the search is cancelled. */
    onCancelSearch: PropTypes.func,
    /** Fired when the text value changes. */
    onChange: PropTypes.func,
    /** Fired when the search icon is clicked. */
    onRequestSearch: PropTypes.func,
    /** Sets placeholder text for the embedded text field. */
    placeholder: PropTypes.string,
    /** Override the search icon. */
    searchIcon: PropTypes.node,
    /** Override the inline-styles of the root element. */
    style: PropTypes.object,
    /** The value of the text field. */
    value: PropTypes.string
};

var SearchBar$1 = withStyles(styles)(SearchBar);

var SEARCH = '@@searchbar/SEARCH';
var CLEAR = '@@searchbar/CLEAR';

var search = function search(payload) {
    return {
        type: SEARCH,
        payload: payload
    };
};

var clear = function clear(payload) {
    return {
        type: CLEAR,
        payload: payload
    };
};

var actions = { search: search, clear: clear };

var styles$1 = function styles(theme) {
    return {
        close: {
            padding: theme.spacing(0.5)
        }
    };
};

var SearchbarProvider = function (_PureComponent) {
    inherits(SearchbarProvider, _PureComponent);

    function SearchbarProvider() {
        classCallCheck(this, SearchbarProvider);

        var _this = possibleConstructorReturn(this, (SearchbarProvider.__proto__ || Object.getPrototypeOf(SearchbarProvider)).call(this));

        _this.processQueue = function () {
            if (_this.props.searchbar) {
                _this.setState({ searchQuery: _this.props.searchbar.options });
                _this.props.clear(_this.props.searchbar.id);
            }
        };

        _this.state = {
            searchQuery: null
        };
        return _this;
    }

    createClass(SearchbarProvider, [{
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            if (this.props.searchbar !== prevProps.searchbar) {
                if (this.props.searchbar) {
                    this.processQueue();
                }
            }
        }
    }, {
        key: 'getChildContext',
        value: function getChildContext() {
            return {
                searchbar: {
                    search: this.props.search,
                    searchQuery: this.state.searchQuery
                }
            };
        }
    }, {
        key: 'render',
        value: function render() {
            var children = this.props.children;

            return React.createElement(
                React.Fragment,
                null,
                children
            );
        }
    }]);
    return SearchbarProvider;
}(PureComponent);

SearchbarProvider.childContextTypes = {
    searchbar: PropTypes.object,
    searchQuery: PropTypes.string
};
SearchbarProvider.propTypes = {
    children: PropTypes.node,
    SearchbarProps: PropTypes.object
};


SearchbarProvider = withStyles$1(styles$1)(SearchbarProvider);

var SearchbarProvider$1 = connect(function (state) {
    return {
        searchbar: state.searchbar.queue[0] || null
    };
}, function (dispatch) {
    return {
        search: function search(options) {
            return dispatch(actions.search({ options: options }));
        },
        clear: function clear(id) {
            return dispatch(actions.clear({ id: id }));
        }
    };
})(SearchbarProvider);

function withSearchbar() {
    return function (Component$$1) {
        var ComponentWithSearchbar = function ComponentWithSearchbar(props, _ref) {
            var searchbar = _ref.searchbar;
            return React.createElement(Component$$1, _extends({
                searchbar: searchbar
            }, props));
        };

        ComponentWithSearchbar.contextTypes = {
            searchbar: PropTypes.object.isRequired
        };

        return ComponentWithSearchbar;
    };
}

var initialState = {
    queue: []
};

var reducer = (function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        type = _ref.type,
        payload = _ref.payload;

    switch (type) {
        case SEARCH:
            return { queue: [].concat(toConsumableArray(state.queue), [_extends({ id: Date.now() }, payload)]) };
        case CLEAR:
            return { queue: state.queue.filter(function (searchbar) {
                    return searchbar.id !== payload.id;
                }) };
        default:
            return state;
    }
});

export { SearchBar$1 as SearchBar, SearchbarProvider$1 as SearchbarProvider, withSearchbar, reducer as searchbarReducer, actions as searchbarActions };
//# sourceMappingURL=index.es.js.map
